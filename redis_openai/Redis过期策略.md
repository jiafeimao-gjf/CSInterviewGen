# 问题：Redis过期策略
回答如下：
「Redis过期策略」 请根据以下内容：
Redis使用定期删除和惰性删除结合的过期策略。定期删除随机检查部分key，惰性删除在访问key时检查是否过期。避免了单次删除过多key导致的性能问题。
 细化回答: 
 要求：1. 回答要详细，内容丰富，实践与理论结合！2. 采用总分总的文章思路！3、适当进行图示说明# Redis 过期策略：定期删除与惰性删除的实践与理论

> **TL;DR**  
> Redis 采用 **主动（定期）删除** 与 **被动（惰性）删除** 的双轨机制，避免一次性大批删除导致性能波动。  
> 通过合理配置 `maxmemory-policy`、`hz`、`lazyfree-lazy-eviction` 等参数，可在保证 **高可用** 与 **低延迟** 的前提下，精准地回收过期键。

---

## 1️⃣ 总论：Redis 过期策略为何重要？

1. **内存占用**  
   - Redis 是内存数据库，所有键值对都驻留在 RAM。过期键若不及时清理，会导致内存泄漏，最终触发 `maxmemory` 限制，甚至引发 OOM。

2. **性能波动**  
   - 单次批量删除大量过期键会产生 **“删除峰值”**，导致 CPU/IO 竞争，出现短暂的 **latency spike**。

3. **一致性与可预测性**  
   - 惰性删除可以在键被访问时即时抛弃，保证查询结果的“实时性”。  
   - 主动删除则可在低负载时消耗资源，降低业务时段的压力。

4. **业务场景差异**  
   - 需要高实时性（如计时器、验证码） → 惰性删除为主。  
   - 需要大量批量清理（如会话缓存） → 主动删除为辅。

---

## 2️⃣ 分析：两种删除方式的实现细节

### 2.1 主动删除（Active Expiration）

| 过程 | 步骤 | 关键参数 | 说明 |
|------|------|----------|------|
| **定期扫描** | 1. `hz` 频率决定扫描周期（默认 10 次/秒） | `hz` | 每秒 10 次 `ACTIVE_EXPIRE` 触发 |
| | 2. 随机抽取 `keysToCheckPerSec`（≈ 5%） | `active-defrag-cycle-factor` | 通过 `KEYS` 随机抽样 |
| | 3. 检查抽样键的过期时间 | `EXPIRE` | 若已过期则调用 `delete()` |
| | 4. 重复直到本次扫描完成 | | |
| **优点** | 在无访问时仍能回收内存 | | |
| **缺点** | 可能触发短暂的 CPU 峰值 | | |

> **典型实现**  
> Redis 采用 **“周期性随机扫描”**（`ActiveExpireCycle`）算法，既不扫描全部键，也不依赖单个键的访问频率。

### 2.2 惰性删除（Lazy Expiration）

| 触发点 | 操作 | 判断 | 结果 |
|--------|------|------|------|
| GET, HGET, MGET 等 | 检查键的过期时间 | `now >= expire` | 删除并返回 NIL |
| EXISTS, DEL, RANK 等 | 先检查是否过期 | | |
| *其他* | 同上 | | |

> **关键**：惰性删除仅在键被访问时才触发。若键从未被访问，即使过期也会留在内存，直到主动扫描发现。

> **优势**  
> - **延迟低**：不必等待后台扫描。  
> - **负载均衡**：删除操作随访问分散，避免峰值。

> **劣势**  
> - 过期键可能长期残留，导致 `maxmemory` 被占用。  
> - 对于长期未访问的键，可能出现 **“老化键”**（stale key）问题。

---

## 3️⃣ 图示：两种删除方式交互流程

```
┌─────────────────────┐
│  User Request 1     │
│  GET key_x          │
└───────┬──────────────┘
        │
        ▼
  +-----------------+
  |  Key Check:     |
  |  key_x.expire?  |
  +--------+--------+
           │
   ┌───────┴───────┐
   | Overdue?      │
   | (yes)         │
   +--------+------+        (1) Lazy delete
           │
           ▼
  +-----------------+
  |  Delete key_x   |
  |  Return NIL     |
  +-----------------+
           │
           ▼
  +-----------------+
  |  Respond NIL    |
  +-----------------+

─────────────┬─────────────
            │ (Background)
            ▼
   ┌─────────────────────────────┐
   |  Active Expire Scheduler    |
   |  (hz=10, 10 times/second)   |
   └──────┬──────────────────────┘
          │
          ▼
+---------------------------+
| Randomly pick ~5% keys   |
| Check if expired         |
| If expired -> delete()   |
+---------------------------+
```

*说明*：  
- **Lazy delete** 发生在用户请求时，直接在访问过程中完成。  
- **Active delete** 则在后台循环运行，随机检查键。

---

## 4️⃣ 实践：如何根据业务场景配置过期策略？

| 场景 | 推荐配置 | 说明 |
|------|----------|------|
| **高并发验证码/一次性令牌** | 1. `maxmemory-policy: volatile-lru`  <br>2. `hz: 10` | 频繁访问，惰性删除足够，主动删除频率不必高。 |
| **会话缓存，访问不均匀** | 1. `maxmemory-policy: allkeys-lru`  <br>2. `hz: 5` <br>3. `lazyfree-lazy-eviction: yes` | 主动扫描与惰性回收并行，降低内存占用。 |
| **时间敏感数据（如限流令牌桶）** | 1. `maxmemory-policy: volatile-ttl`  <br>2. `hz: 20` | `volatile-ttl` 会优先回收最近到期键，配合高频扫描，降低过期键残留。 |
| **低内存服务器** | 1. `maxmemory-policy: allkeys-lfu` <br>2. `hz: 5` | LFU + 低频扫描，避免频繁扫描导致 CPU 峰值。 |
| **多实例分布式部署** | 1. `maxmemory-policy: volatile-lru` <br>2. `hz: 10` <br>3. `lazyfree-lazy-expire: yes` | 每个实例独立回收，`lazyfree` 确保删除异步，避免阻塞。 |

### 4.1 参数解释

| 参数 | 默认值 | 作用 |
|------|--------|------|
| `maxmemory-policy` | `volatile-lru` | 过期键清除策略，决定键被删除的顺序。|
| `hz` | `10` | 主动删除频率（每秒触发次数）。|
| `lazyfree-lazy-eviction` | `no` | 对于主动删除导致的内存回收，是否异步执行。|
| `lazyfree-lazy-expire` | `no` | 惰性删除时是否异步执行。|

> **Tip**：在高并发环境下，开启 `lazyfree` 可显著降低 **命令阻塞时间**，但会增加 CPU 使用率。根据硬件与业务需求平衡。

---

## 5️⃣ 性能调优：监控与诊断

### 5.1 监控指标

| 指标 | 命令 | 说明 |
|------|------|------|
| **过期键数量** | `info persistence`  → `expired_keys` | 统计已过期且已被清除的键数。 |
| **每秒扫描次数** | `info stats`  → `expired_keys_per_scan` | 每次主动扫描中被删除的键数。 |
| **命令延迟** | `latency doctor` | 检测 `expired_keys` 相关命令导致的峰值。 |
| **内存使用** | `info memory` | 监控 `used_memory_peak` 与 `maxmemory`。 |

### 5.2 调整步骤

1. **监测**  
   - 在业务高峰前后收集 `expired_keys` 与 `expired_keys_per_scan`。  
   - 若 `expired_keys` 持续增长，说明过期键回收不及时。

2. **调高 `hz`**  
   - 增加 `hz`（例如 20 或 30）能提升主动扫描频率。  
   - 需要评估 CPU 占用与业务峰值延迟的平衡。

3. **启用 `lazyfree`**  
   - 开启 `lazyfree-lazy-eviction` 与 `lazyfree-lazy-expire` 可将删除操作异步化。  
   - 适用于 **写多读少** 或 **IO 密集** 的场景。

4. **更改 `maxmemory-policy`**  
   - 若 `volatile-lru` 仍无法满足需求，可改为 `volatile-ttl`，优先回收最近到期键。

5. **检查 `maxmemory` 配置**  
   - 过低的 `maxmemory` 可能导致频繁触发过期，导致性能问题。  
   - 通过 `maxmemory-reserve` 预留安全内存，防止因过期导致 OOM。

---

## 6️⃣ 小结：双轨机制的核心价值

> **主**：主动删除  
> - **目标**：避免“一次性大删除”导致的性能峰值。  
> - **机制**：周期性随机扫描，逐步回收过期键。  
> - **优点**：可预测的资源消耗；对无访问键也能回收。  

> **惰**：惰性删除  
> - **目标**：在业务请求中即时清理已过期键。  
> - **机制**：每次键访问时检查是否过期，立即删除。  
> - **优点**：低延迟；删除成本均摊到业务流。  

这两种策略 **互补**：  
- 惰性删除负责“即时”回收；  
- 主动删除负责“深层”回收。  

通过合理配置与监控，Redis 能在 **内存占用**、**响应延迟** 与 **CPU 负载** 三者之间实现平衡，满足大多数业务场景的需求。

---

> **下一步建议**  
> 1. 在生产环境中部署监控（Prometheus + Grafana）收集过期相关指标。  
> 2. 对业务关键数据使用 `volatile-ttl` 或 `allkeys-lfu`，提高过期键清理效率。  
> 3. 在高峰时段考虑开启 `lazyfree`，将删除任务异步化，减少命令阻塞。  

祝你在 Redis 的缓存优化道路上越走越顺！ 🚀