# 问题：什么是动态规划？它的核心思想是什么？
回答如下：
# 动态规划：从理论到实战的深度解析

作为一名拥有10年开发经验的高级开发者，我想从多个维度来深入剖析动态规划这个重要算法思想。

## 一、动态规划的本质理解

### 1.1 核心概念
动态规划（Dynamic Programming）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。它将复杂问题分解成一系列相互重叠的子问题，通过求解子问题来解决原问题。

### 1.2 与分治法的区别
```
分治法：子问题相互独立
动态规划：子问题存在重叠，需要存储中间结果
```

## 二、核心思想详解

### 2.1 最优子结构
这是动态规划的基础。一个问题的最优解包含其子问题的最优解。

```java
// 斐波那契数列 - 最优子结构体现
public int fib(int n) {
    if (n <= 1) return n;
    // F(n) = F(n-1) + F(n-2)
    return fib(n-1) + fib(n-2); // 这里体现了最优子结构
}
```

### 2.2 重叠子问题
这是动态规划的关键特征，通过记忆化避免重复计算。

```java
// 带记忆化的斐波那契 - 避免重复计算
public int fibMemo(int n, int[] memo) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];
    
    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
    return memo[n];
}
```

### 2.3 状态转移方程
这是动态规划的核心，定义了如何从已知状态推导出未知状态。

## 三、经典问题实战分析

### 3.1 背包问题（0-1背包）
```java
public int knapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    // dp[i][w] 表示前i个物品在容量为w时的最大价值
    int[][] dp = new int[n + 1][capacity + 1];
    
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            // 不选择第i个物品
            dp[i][w] = dp[i-1][w];
            
            // 如果能装下第i个物品，考虑选择它
            if (weights[i-1] <= w) {
                dp[i][w] = Math.max(dp[i][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]);
            }
        }
    }
    
    return dp[n][capacity];
}
```

### 3.2 最长公共子序列（LCS）
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length(), n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i-1) == text2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[m][n];
}
```

## 四、工程实践中的应用

### 4.1 缓存系统设计
```java
// LRU缓存中的动态规划思想
public class LRUCache {
    // 使用双向链表 + 哈希表，状态转移思想体现在节点移动策略
    private Map<Integer, Node> cache;
    private int capacity;
    
    public void get(int key) {
        // 访问时更新节点位置 - 状态转移
        updatePosition(key);
    }
}
```

### 4.2 算法优化实践
```java
// 实际项目中的动态规划优化
public class Solution {
    // 原始递归解法 - 时间复杂度O(2^n)
    public int climbStairs1(int n) {
        if (n <= 2) return n;
        return climbStairs1(n-1) + climbStairs1(n-2);
    }
    
    // 动态规划优化 - 时间复杂度O(n)
    public int climbStairs2(int n) {
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[1] = 1; dp[2] = 2;
        
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
```

## 五、性能优化策略

### 5.1 空间优化
```java
// 空间复杂度从O(n)优化到O(1)
public int climbStairs(int n) {
    if (n <= 2) return n;
    
    int prev2 = 1, prev1 = 2, current = 0;
    for (int i = 3; i <= n; i++) {
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    return current;
}
```

### 5.2 状态压缩
```java
// 二维状态压缩为一维
public int maxProfit(int[] prices) {
    int hold = Integer.MIN_VALUE; // 持有股票的最大收益
    int sold = 0;                 // 不持有股票的最大收益
    
    for (int price : prices) {
        hold = Math.max(hold, -price);        // 买入
        sold = Math.max(sold, hold + price);  // 卖出
    }
    
    return sold;
}
```

## 六、常见陷阱与注意事项

### 6.1 状态定义错误
```java
// ❌ 错误示例：状态定义不清晰
int[][] dp = new int[n][n]; // 不应该这样定义状态

// ✅ 正确示例：明确状态含义
int[][] dp = new int[n][2]; // 0表示不持股，1表示持股
```

### 6.2 边界条件处理
```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    if (n == 0) return 0;
    if (n == 1) return cost[0];
    
    // dp[i] 表示到达第i个台阶的最小花费
    int[] dp = new int[n + 1];
    dp[0] = cost[0];
    dp[1] = cost[1];
    
    for (int i = 2; i < n; i++) {
        dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
    }
    
    // 可以从倒数第一或第二台阶到达终点
    return Math.min(dp[n-1], dp[n-2]);
}
```

## 七、工程应用总结

### 7.1 适用场景
1. **最优化问题**：最大值、最小值问题
2. **计数问题**：有多少种方案
3. **存在性问题**：是否存在某种解
4. **路径问题**：最短路径、最优路径

### 7.2 设计模式
```java
// 动态规划模板类
public abstract class DPBase {
    protected int[][] memo;
    
    protected void initMemo(int rows, int cols) {
        memo = new int[rows][cols];
        for (int[] row : memo) {
            Arrays.fill(row, -1); // -1表示未计算
        }
    }
    
    protected abstract int solve(int... args);
}
```

## 八、个人经验总结

作为一名资深开发者，我认为动态规划的核心在于：

1. **抽象能力**：能将实际问题抽象为数学模型
2. **状态设计**：合理定义状态是成功的关键
3. **边界处理**：细节决定成败
4. **性能意识**：平衡时间和空间复杂度

动态规划不是万能的，但在特定场景下能带来质的提升。在实际项目中，我会根据问题特点选择合适的解法，有时会结合贪心、分治等其他算法思想。

记住：**动态规划的本质是通过存储中间结果来避免重复计算，核心是找到状态转移方程！**

这10年的开发经验告诉我，掌握动态规划不仅是为了面试，更是为了在面对复杂问题时能够有系统性的解决思路。[DONE]