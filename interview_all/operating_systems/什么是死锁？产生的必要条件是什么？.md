# 问题：什么是死锁？产生的必要条件是什么？
回答如下：
作为一名有10年开发经验的高级开发者，让我从理论到实践全面解析死锁这个经典问题。

## 什么是死锁？

死锁（Deadlock）是指两个或多个进程/线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。简单说就是：**A等B，B等A，谁也别想动**。

## 死锁产生的四个必要条件

### 1. 互斥条件（Mutual Exclusion）
资源不能被多个线程同时使用，必须独占。
```java
// 实际案例：数据库连接池死锁
public class DatabaseConnection {
    private static final Object lock = new Object();
    
    public void methodA() {
        synchronized(lock) {  // 获得锁
            // 模拟耗时操作
            Thread.sleep(1000);
            methodB();  // 可能导致死锁
        }
    }
    
    public void methodB() {
        synchronized(lock) {  // 再次尝试获取同一把锁
            // ...
        }
    }
}
```

### 2. 请求和保持条件（Hold and Wait）
进程已经保持至少一个资源，同时又请求其他被占用的资源。
```java
// 线程1：持有A锁，等待B锁
Thread1: 
synchronized(lockA) {
    // 持有lockA
    synchronized(lockB) {  // 尝试获取lockB
        // ...
    }
}

// 线程2：持有B锁，等待A锁  
Thread2:
synchronized(lockB) {
    // 持有lockB
    synchronized(lockA) {  // 尝试获取lockA
        // ...
    }
}
```

### 3. 不可剥夺条件（No Preemption）
已分配的资源不能被强制释放，只能由获得该资源的进程主动释放。
```java
// 实际场景：文件锁死锁
public class FileLockExample {
    public void processFile(String file1, String file2) {
        // 获取第一个文件锁
        try (FileChannel channel1 = FileChannel.open(Paths.get(file1), StandardOpenOption.WRITE)) {
            FileLock lock1 = channel1.lock();
            
            // 模拟处理时间
            Thread.sleep(100);
            
            // 尝试获取第二个文件锁（可能死锁）
            try (FileChannel channel2 = FileChannel.open(Paths.get(file2), StandardOpenOption.WRITE)) {
                FileLock lock2 = channel2.lock();
                // 处理文件...
            }
        } catch (IOException | InterruptedException e) {
            // ...
        }
    }
}
```

### 4. 循环等待条件（Circular Wait）
存在一种进程资源的循环等待链，每个进程都在等待下一个进程所占有的资源。
```java
// 死锁示例：多个线程按不同顺序获取锁
public class CircularWaitExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    private final Object lock3 = new Object();
    
    public void thread1() {
        synchronized(lock1) {  // 获取lock1
            System.out.println("Thread1 got lock1");
            synchronized(lock2) {  // 获取lock2
                System.out.println("Thread1 got lock2");
                // ...
            }
        }
    }
    
    public void thread2() {
        synchronized(lock2) {  // 获取lock2
            System.out.println("Thread2 got lock2");
            synchronized(lock3) {  // 获取lock3
                System.out.println("Thread2 got lock3");
                // ...
            }
        }
    }
    
    public void thread3() {
        synchronized(lock3) {  // 获取lock3
            System.out.println("Thread3 got lock3");
            synchronized(lock1) {  // 获取lock1（形成循环等待）
                System.out.println("Thread3 got lock1");
                // ...
            }
        }
    }
}
```

## 实际项目中的死锁场景

### 场景1：数据库事务死锁
```java
@Service
public class OrderService {
    
    @Transactional
    public void processOrder(Long orderId) {
        // 事务A：先锁定订单表
        Order order = orderRepository.findById(orderId);
        order.setStatus("PROCESSING");
        
        // 模拟其他业务操作
        Thread.sleep(1000);
        
        // 可能死锁：如果另一个线程已经持有库存锁
        inventoryService.updateStock(order.getProductId(), -1);
    }
    
    @Transactional
    public void updateInventory(Long productId) {
        // 事务B：先锁定库存表
        Inventory inventory = inventoryRepository.findById(productId);
        inventory.setStock(inventory.getStock() - 1);
        
        // 模拟其他业务操作
        Thread.sleep(1000);
        
        // 可能死锁：如果另一个线程已经持有订单锁
        orderService.processOrder(inventory.getOrderId());
    }
}
```

### 场景2：多线程缓存更新死锁
```java
@Component
public class CacheManager {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    private final Map<String, Object> lockMap = new ConcurrentHashMap<>();
    
    public Object getData(String key) {
        // 获取全局锁
        Object globalLock = getGlobalLock();
        synchronized(globalLock) {
            // 先检查缓存
            if (cache.containsKey(key)) {
                return cache.get(key);
            }
            
            // 缓存未命中，需要从数据源获取
            Object data = fetchDataFromSource(key);
            
            // 检查是否有其他线程正在更新此key的缓存
            Object keyLock = lockMap.computeIfAbsent(key, k -> new Object());
            synchronized(keyLock) {
                // 再次检查缓存（双重检查）
                if (!cache.containsKey(key)) {
                    cache.put(key, data);
                }
            }
            
            return cache.get(key);
        }
    }
}
```

## 预防死锁的实践策略

### 1. 锁排序原则
```java
public class LockOrderExample {
    private final Object lockA = new Object();
    private final Object lockB = new Object();
    
    // 统一按顺序获取锁
    public void method1() {
        // 按固定顺序获取锁
        synchronized(lockA) {
            synchronized(lockB) {
                // 业务逻辑
            }
        }
    }
    
    public void method2() {
        // 必须按照相同顺序获取锁
        synchronized(lockA) {
            synchronized(lockB) {
                // 业务逻辑
            }
        }
    }
}
```

### 2. 超时机制
```java
public class TimeoutLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    
    public boolean tryOperationWithTimeout() {
        try {
            // 尝试获取锁，超时时间为5秒
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                try {
                    // 执行业务逻辑
                    return true;
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println("获取锁超时");
                return false;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

### 3. 死锁检测工具
```java
// 使用JVM工具检测死锁
public class DeadlockDetector {
    
    public void detectDeadlock() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] threadIds = threadBean.findDeadlockedThreads();
        
        if (threadIds != null) {
            ThreadInfo[] threadInfos = threadBean.getThreadInfo(threadIds);
            System.out.println("发现死锁线程:");
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println(threadInfo);
            }
        }
    }
}
```

## 监控和诊断

### 1. 日志监控
```java
@Component
public class LockMonitor {
    
    private static final Logger logger = LoggerFactory.getLogger(LockMonitor.class);
    
    public void monitorLockAcquisition(Object lock, String operation) {
        // 记录锁获取时间
        long startTime = System.currentTimeMillis();
        
        try {
            synchronized(lock) {
                long duration = System.currentTimeMillis() - startTime;
                if (duration > 1000) {  // 超过1秒记录警告
                    logger.warn("Lock acquisition took {}ms for operation: {}", 
                               duration, operation);
                }
                // 执行业务逻辑
            }
        } catch (Exception e) {
            logger.error("Lock operation failed", e);
        }
    }
}
```

### 2. 应用级监控
```java
@RestController
public class MonitorController {
    
    @Autowired
    private ThreadMXBean threadBean;
    
    @GetMapping("/deadlock-check")
    public ResponseEntity<Map<String, Object>> checkDeadlock() {
        Map<String, Object> result = new HashMap<>();
        
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        result.put("hasDeadlock", deadlockedThreads != null && deadlockedThreads.length > 0);
        
        if (deadlockedThreads != null) {
            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreads);
            result.put("deadlockDetails", threadInfos);
        }
        
        return ResponseEntity.ok(result);
    }
}
```

## 总结

死锁是并发编程中的经典难题，作为高级开发者需要：

1. **深刻理解**死锁的四个必要条件
2. **在设计阶段**就考虑锁的获取顺序和超时机制
3. **建立监控体系**及时发现潜在死锁风险
4. **持续优化**代码质量，避免复杂锁依赖关系

记住：**预防胜于治疗**，良好的架构设计和编码规范是避免死锁的最佳方案。[DONE]