# 问题：什么是负载均衡？有哪些负载均衡算法？
回答如下：
作为一名有10年开发经验的高级开发者，我来详细解析负载均衡这个核心架构概念。

## 什么是负载均衡？

负载均衡（Load Balancing）是一种分布式系统设计技术，通过将工作负载分发到多个计算资源（服务器、进程、线程等）上，实现以下目标：

### 核心价值
- **高可用性**：避免单点故障，提高系统容错能力
- **性能优化**：合理分配请求，避免某些节点过载
- **扩展性**：支持水平扩展，动态增加处理能力
- **资源利用**：最大化硬件资源利用率

## 负载均衡的工作原理

```java
// 经典的负载均衡器架构示例
public class LoadBalancer {
    private List<Server> servers;
    private AtomicInteger currentIndex = new AtomicInteger(0);
    
    public Server getServer() {
        // 负载均衡算法的核心逻辑
        return selectServer();
    }
}
```

## 主流负载均衡算法详解

### 1. 轮询（Round Robin）
**原理**：按顺序将请求分发给每个服务器
```java
public class RoundRobinLoadBalancer implements LoadBalancer {
    private AtomicInteger counter = new AtomicInteger(0);
    
    @Override
    public Server select(List<Server> servers) {
        int index = Math.abs(counter.getAndIncrement()) % servers.size();
        return servers.get(index);
    }
}
```
**适用场景**：服务器性能相近，简单场景
**优缺点**：
- ✅ 实现简单，公平性好
- ❌ 无法考虑服务器实时负载

### 2. 加权轮询（Weighted Round Robin）
**原理**：根据服务器性能分配权重
```java
public class WeightedRoundRobinLoadBalancer {
    private List<Server> servers;
    
    public Server select() {
        // 基于权重的轮询算法
        int totalWeight = servers.stream()
            .mapToInt(Server::getWeight)
            .sum();
            
        int currentWeight = random.nextInt(totalWeight);
        // 实现权重分配逻辑
        return selectByWeight(currentWeight);
    }
}
```
**适用场景**：服务器性能差异明显
**实践建议**：权重设置需要根据实际监控数据动态调整

### 3. 随机算法（Random）
**原理**：随机选择服务器
```java
public class RandomLoadBalancer implements LoadBalancer {
    private Random random = new Random();
    
    @Override
    public Server select(List<Server> servers) {
        return servers.get(random.nextInt(servers.size()));
    }
}
```
**适用场景**：简单快速，适合无状态服务
**注意**：可能造成负载不均

### 4. 最少连接数（Least Connections）
**原理**：选择当前连接数最少的服务器
```java
public class LeastConnectionsLoadBalancer implements LoadBalancer {
    @Override
    public Server select(List<Server> servers) {
        return servers.stream()
            .min(Comparator.comparingInt(Server::getActiveConnections))
            .orElseThrow();
    }
}
```
**适用场景**：处理时间差异大的场景
**实践要点**：
- 需要实时监控连接数
- 可能存在连接数更新延迟

### 5. 响应时间权重（Least Response Time）
**原理**：基于平均响应时间选择服务器
```java
public class LeastResponseTimeLoadBalancer {
    public Server select(List<Server> servers) {
        return servers.stream()
            .min(Comparator.comparingDouble(server -> 
                server.getAverageResponseTime() * (1.0 / server.getWeight())
            ))
            .orElseThrow();
    }
}
```
**适用场景**：需要快速响应的实时系统
**监控维度**：
- 平均响应时间
- 95%响应时间
- 错误率

### 6. IP哈希算法（IP Hash）
**原理**：根据客户端IP计算哈希值，保证同一客户端固定到同一服务器
```java
public class IpHashLoadBalancer {
    public Server select(List<Server> servers, String clientIp) {
        int hash = clientIp.hashCode();
        int index = Math.abs(hash) % servers.size();
        return servers.get(index);
    }
}
```
**适用场景**：需要会话保持的场景
**注意事项**：
- 服务器扩容时可能需要重新分布
- 可能导致负载不均

## 实际项目中的应用经验

### 微服务架构中的负载均衡
```yaml
# Spring Cloud 示例配置
spring:
  cloud:
    loadbalancer:
      config:
        strategy: RoundRobin
        retry:
          enabled: true
```

### Nginx 配置实战
```nginx
upstream backend {
    server 192.168.1.10:8080 weight=3;
    server 192.168.1.11:8080 weight=2;
    server 192.168.1.12:8080 backup;
    
    # 健康检查
    keepalive 32;
}
```

## 高级负载均衡策略

### 动态权重调整
```java
public class AdaptiveLoadBalancer {
    private volatile Map<Server, Double> weights = new ConcurrentHashMap<>();
    
    public void updateWeights() {
        // 根据实时监控数据动态调整权重
        servers.forEach(server -> {
            double healthScore = calculateHealthScore(server);
            weights.put(server, normalizeWeight(healthScore));
        });
    }
}
```

### 混合算法
```java
public class HybridLoadBalancer implements LoadBalancer {
    private final List<LoadBalancerStrategy> strategies;
    
    @Override
    public Server select(List<Server> servers) {
        // 结合多种策略进行综合判断
        return strategies.stream()
            .map(strategy -> strategy.select(servers))
            .filter(Objects::nonNull)
            .findFirst()
            .orElseThrow();
    }
}
```

## 监控与优化实践

### 关键监控指标
```java
public class LoadBalancerMetrics {
    private final MeterRegistry registry;
    
    public void recordServerHealth(Server server, long responseTime) {
        Timer.Sample sample = Timer.start(registry);
        // 记录响应时间、错误率、连接数等指标
        Gauge.builder("server.health.score")
            .register(registry, server, s -> calculateHealthScore(s));
    }
}
```

### 自适应调整
```java
public class AdaptiveLoadBalancer {
    private ScheduledExecutorService scheduler = 
        Executors.newScheduledThreadPool(1);
    
    public void startMonitoring() {
        scheduler.scheduleAtFixedRate(() -> {
            // 根据监控数据动态调整策略
            adjustLoadBalancingStrategy();
        }, 0, 30, TimeUnit.SECONDS);
    }
}
```

## 最佳实践总结

### 选择原则
1. **业务场景优先**：根据请求特征选择算法
2. **性能指标驱动**：基于实际监控数据优化
3. **可扩展性考虑**：支持动态扩容和缩容
4. **故障处理机制**：完善的健康检查和降级策略

### 常见陷阱避免
- ❌ 过度依赖单一算法
- ❌ 忽视服务器真实负载情况
- ❌ 缺乏监控和调优机制
- ❌ 没有考虑服务状态变化

负载均衡是构建高可用系统的核心组件，需要结合具体的业务场景、技术栈和运维能力来选择最适合的方案。关键是要持续监控、动态调整，形成完整的闭环管理。[DONE]