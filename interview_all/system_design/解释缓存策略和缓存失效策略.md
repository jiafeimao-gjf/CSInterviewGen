# 问题：解释缓存策略和缓存失效策略
回答如下：
# 缓存策略与缓存失效策略详解

作为一名拥有10年开发经验的高级开发者，我深知缓存是系统性能优化的核心手段。让我从理论到实践，系统性地解析这个重要话题。

## 一、缓存策略概述

### 1.1 基础概念
缓存策略决定了数据在缓存中的存储方式、访问机制和更新时机。好的缓存策略能显著提升系统响应速度和资源利用率。

### 1.2 核心缓存模式

#### 1.2.1 Cache-Aside Pattern（旁路缓存）
```java
// Java示例：典型的旁路缓存实现
public class UserService {
    private final RedisTemplate<String, User> redisTemplate;
    private final UserRepository userRepository;
    
    public User getUserById(Long userId) {
        // 1. 先查缓存
        String key = "user:" + userId;
        User user = redisTemplate.opsForValue().get(key);
        
        if (user == null) {
            // 2. 缓存未命中，查数据库
            user = userRepository.findById(userId);
            
            if (user != null) {
                // 3. 数据库查询结果写入缓存
                redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
            }
        }
        
        return user;
    }
}
```

#### 1.2.2 Write-Through Pattern（写穿透）
```java
// 写操作同时更新缓存和数据库
public void updateUser(User user) {
    // 先更新数据库
    userRepository.save(user);
    
    // 然后更新缓存
    String key = "user:" + user.getId();
    redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
}
```

#### 1.2.3 Write-Behind Pattern（写回）
```java
// 异步批量更新缓存，适合高并发场景
public class AsyncCacheUpdater {
    private final BlockingQueue<CacheUpdateTask> taskQueue = new LinkedBlockingQueue<>();
    
    public void updateAsync(String key, Object value) {
        taskQueue.offer(new CacheUpdateTask(key, value));
    }
    
    // 定时批量处理任务
    @Scheduled(fixedDelay = 5000)
    public void processBatch() {
        List<CacheUpdateTask> tasks = new ArrayList<>();
        taskQueue.drainTo(tasks);
        
        // 批量更新缓存
        tasks.forEach(task -> {
            redisTemplate.opsForValue().set(task.getKey(), task.getValue(), 30, TimeUnit.MINUTES);
        });
    }
}
```

## 二、缓存策略深度解析

### 2.1 分层缓存策略

#### 应用层缓存（Local Cache）
```java
// Caffeine本地缓存示例
@Configuration
public class CacheConfig {
    @Bean
    public Cache<String, User> userCache() {
        return Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .recordStats()
                .build();
    }
}
```

#### 分布式缓存（Redis）
```java
// Redis缓存策略配置
public class RedisCacheManager {
    // 读写分离策略
    public String getFromCache(String key) {
        // 先从主节点读取
        String value = primaryRedis.get(key);
        
        if (value == null) {
            // 主节点未命中，从从节点读取（降低主节点压力）
            value = replicaRedis.get(key);
            
            // 如果从节点有数据，更新到主节点
            if (value != null) {
                primaryRedis.setex(key, value, 30 * 60);
            }
        }
        
        return value;
    }
}
```

### 2.2 多级缓存架构

```java
public class MultiLevelCache {
    private final LocalCache localCache;
    private final RedisCache redisCache;
    private final DatabaseCache databaseCache;
    
    public Object get(String key) {
        // 1. 先查本地缓存
        Object result = localCache.get(key);
        if (result != null) {
            return result;
        }
        
        // 2. 查Redis缓存
        result = redisCache.get(key);
        if (result != null) {
            // 3. 缓存穿透保护
            localCache.put(key, result);
            return result;
        }
        
        // 4. 最后查数据库
        result = databaseCache.get(key);
        if (result != null) {
            // 5. 写入多级缓存
            redisCache.put(key, result);
            localCache.put(key, result);
        }
        
        return result;
    }
}
```

## 三、缓存失效策略

### 3.1 主动失效策略

#### 3.1.1 TTL（Time To Live）策略
```java
// 基于时间的自动过期
public class TimeBasedInvalidation {
    public void cacheWithTTL(String key, Object value, long ttlSeconds) {
        // Redis设置过期时间
        redisTemplate.opsForValue().set(key, value, ttlSeconds, TimeUnit.SECONDS);
        
        // 同时设置一个监控用的key，用于统计
        String monitorKey = "monitor:ttl:" + key;
        redisTemplate.opsForValue().set(monitorKey, System.currentTimeMillis(), 
                                       ttlSeconds + 300, TimeUnit.SECONDS);
    }
}
```

#### 3.1.2 主动更新策略
```java
@Component
public class CacheUpdateManager {
    
    @EventListener
    public void handleUserUpdated(UserUpdatedEvent event) {
        // 根据业务规则主动清除相关缓存
        String userId = event.getUserId();
        
        // 清除用户基本信息缓存
        redisTemplate.delete("user:" + userId);
        
        // 清除相关的权限缓存
        redisTemplate.delete("user:permissions:" + userId);
        
        // 清除缓存统计信息
        redisTemplate.delete("cache:stats:user:" + userId);
    }
}
```

### 3.2 被动失效策略

#### 3.2.1 缓存穿透防护
```java
// 空值缓存策略
public class AntiPenetrationCache {
    private static final String NULL_VALUE = "NULL";
    
    public User getUser(Long userId) {
        String key = "user:" + userId;
        
        // 先查缓存
        String cached = redisTemplate.opsForValue().get(key);
        
        if (NULL_VALUE.equals(cached)) {
            return null; // 缓存了空值，直接返回null
        }
        
        User user = userRepository.findById(userId);
        
        if (user == null) {
            // 为空值设置短时缓存（防止高频查询数据库）
            redisTemplate.opsForValue().set(key, NULL_VALUE, 5, TimeUnit.MINUTES);
        } else {
            // 正常数据缓存
            redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);
        }
        
        return user;
    }
}
```

#### 3.2.2 缓存雪崩防护
```java
// 布隆过滤器 + 随机过期时间
@Component
public class CacheAvalancheProtection {
    
    // 使用布隆过滤器预判key是否存在
    private final BloomFilter<String> bloomFilter = BloomFilter.create(
        Funnels.stringFunnel(Charset.defaultCharset()), 
        1000000, 0.01
    );
    
    public Object getWithProtection(String key) {
        // 布隆过滤器判断key是否存在
        if (!bloomFilter.mightContain(key)) {
            return null; // 直接返回，不查询缓存和数据库
        }
        
        // 生成随机过期时间（避免同时失效）
        int randomTTL = 30 + new Random().nextInt(30);
        
        Object value = redisTemplate.opsForValue().get(key);
        if (value == null) {
            // 缓存未命中，查询数据库并设置随机过期时间
            value = queryDatabase(key);
            if (value != null) {
                redisTemplate.opsForValue().set(key, value, randomTTL, TimeUnit.MINUTES);
            }
        }
        
        return value;
    }
}
```

### 3.3 智能失效策略

#### 3.3.1 基于访问频率的智能淘汰
```java
// LRU + 访问频次混合算法
public class SmartEvictionCache {
    
    private final Map<String, CacheEntry> cache = new LinkedHashMap<String, CacheEntry>() {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, CacheEntry> eldest) {
            // 当缓存大小超过阈值时，根据访问频次和时间进行淘汰
            return size() > MAX_CACHE_SIZE && shouldEvict(eldest.getValue());
        }
    };
    
    private boolean shouldEvict(CacheEntry entry) {
        long currentTime = System.currentTimeMillis();
        long age = currentTime - entry.getCreateTime();
        int accessCount = entry.getAccessCount();
        
        // 访问频次低且存活时间长的优先淘汰
        return (accessCount < 3 && age > 3600000) || age > 86400000;
    }
}
```

#### 3.3.2 基于业务规则的失效
```java
// 业务感知的缓存失效
public class BusinessAwareInvalidation {
    
    public void invalidateByBusinessRule(String businessKey, String ruleType) {
        switch (ruleType) {
            case "user_role_change":
                // 角色变更，清除用户相关权限缓存
                redisTemplate.delete("user:permissions:*");
                break;
            case "product_price_change":
                // 价格变更，清除商品列表缓存
                redisTemplate.delete("product:list:*");
                break;
            case "system_config_update":
                // 系统配置更新，清除所有相关缓存
                redisTemplate.delete("config:*");
                break;
        }
    }
}
```

## 四、实践中的最佳实践

### 4.1 缓存策略选择原则

```java
// 缓存策略决策引擎
public class CacheStrategySelector {
    
    public CacheStrategy selectStrategy(String cacheKey, Object data) {
        // 根据数据特征选择缓存策略
        if (isFrequentlyAccessed(data)) {
            return CacheStrategy.READ_THROUGH;
        }
        
        if (isSensitiveToConsistency(data)) {
            return CacheStrategy.WRITE_BEHIND;
        }
        
        if (isLargeData(data)) {
            return CacheStrategy.CACHE_ASIDE;
        }
        
        return CacheStrategy.DEFAULT;
    }
    
    private boolean isFrequentlyAccessed(Object data) {
        // 实现频率判断逻辑
        return true;
    }
    
    private boolean isSensitiveToConsistency(Object data) {
        // 实现一致性敏感度判断
        return false;
    }
    
    private boolean isLargeData(Object data) {
        // 实现数据大小判断
        return true;
    }
}
```

### 4.2 监控与调优

```java
// 缓存监控统计
@Component
public class CacheMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public void recordCacheHit(String cacheName, String key) {
        Counter.builder("cache.hits")
                .tag("cache", cacheName)
                .tag("key", key)
                .register(meterRegistry)
                .increment();
    }
    
    public void recordCacheMiss(String cacheName, String key) {
        Counter.builder("cache.misses")
                .tag("cache", cacheName)
                .tag("key", key)
                .register(meterRegistry)
                .increment();
    }
    
    @Scheduled(fixedRate = 60000)
    public void reportCacheStats() {
        // 定期上报缓存命中率等统计信息
        double hitRate = calculateHitRate();
        log.info("Cache Hit Rate: {}%", hitRate * 100);
    }
}
```

## 五、常见问题与解决方案

### 5.1 缓存一致性问题
- **解决方案**：采用最终一致性模型，通过消息队列保证数据同步

### 5.2 缓存热点问题
- **解决方案**：引入分布式锁，控制热点数据的更新频率

### 5.3 内存溢出问题
- **解决方案**：合理设置缓存大小和淘汰策略，监控内存使用情况

## 总结

缓存策略的选择需要根据具体的业务场景、数据特征和性能要求来决定。作为高级开发者，我们应该：

1. **理解业务本质**：不同业务对缓存的一致性、实时性要求不同
2. **设计多层防护**：从本地缓存到分布式缓存，形成完整的保护机制
3. **建立监控体系**：实时监控缓存性能，及时发现和解决问题
4. **持续优化调优**：根据实际运行数据不断调整缓存策略

记住，没有最好的缓存策略，只有最适合的缓存策略。[DONE]